<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libwebsockets: lws_context_creation_info Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libwebsockets.org-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libwebsockets
   </div>
   <div id="projectbrief">Lightweight C library for HTML5 websockets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structlws__context__creation__info.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">lws_context_creation_info Struct Reference<div class="ingroups"><a class="el" href="group__context-and-vhost.html">Context-and-vhost</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="libwebsockets_8h_source.html">libwebsockets.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a424a5ce268d6903e42243be94487ab85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a424a5ce268d6903e42243be94487ab85">port</a></td></tr>
<tr class="separator:a424a5ce268d6903e42243be94487ab85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75434932bb5df54665ea678eb8ac104a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a75434932bb5df54665ea678eb8ac104a">iface</a></td></tr>
<tr class="separator:a75434932bb5df54665ea678eb8ac104a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb90ffb3e6d6db2db20f529d61bd9122"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#abb90ffb3e6d6db2db20f529d61bd9122">protocols</a></td></tr>
<tr class="separator:abb90ffb3e6d6db2db20f529d61bd9122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3d1155fc52f5048b481884f6fb947c"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__extension.html">lws_extension</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a4a3d1155fc52f5048b481884f6fb947c">extensions</a></td></tr>
<tr class="separator:a4a3d1155fc52f5048b481884f6fb947c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a75b7b259a3c3a5fbb4219a3f06c29"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__token__limits.html">lws_token_limits</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ac8a75b7b259a3c3a5fbb4219a3f06c29">token_limits</a></td></tr>
<tr class="separator:ac8a75b7b259a3c3a5fbb4219a3f06c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fb447be15c4fcb01d3285a6678ab54"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#af3fb447be15c4fcb01d3285a6678ab54">ssl_private_key_password</a></td></tr>
<tr class="separator:af3fb447be15c4fcb01d3285a6678ab54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62b0f0e8e402412ba5011d15c244103"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ac62b0f0e8e402412ba5011d15c244103">ssl_cert_filepath</a></td></tr>
<tr class="separator:ac62b0f0e8e402412ba5011d15c244103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ec8893e0f7843cf5d783d2f350ef14"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ab9ec8893e0f7843cf5d783d2f350ef14">ssl_private_key_filepath</a></td></tr>
<tr class="separator:ab9ec8893e0f7843cf5d783d2f350ef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8e65c3a059d3b586fafa9ef3282c29"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a4f8e65c3a059d3b586fafa9ef3282c29">ssl_ca_filepath</a></td></tr>
<tr class="separator:a4f8e65c3a059d3b586fafa9ef3282c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1516fd7fed26bfa77c0246ed26c2eb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a3e1516fd7fed26bfa77c0246ed26c2eb">ssl_cipher_list</a></td></tr>
<tr class="separator:a3e1516fd7fed26bfa77c0246ed26c2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef917c0b23976a264d2474901b4f5aa3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#aef917c0b23976a264d2474901b4f5aa3">http_proxy_address</a></td></tr>
<tr class="separator:aef917c0b23976a264d2474901b4f5aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b59f2bdc869871e7bde232db94f5ca6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a7b59f2bdc869871e7bde232db94f5ca6">http_proxy_port</a></td></tr>
<tr class="separator:a7b59f2bdc869871e7bde232db94f5ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9d22437de92c197f3cee52912b2c03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a9c9d22437de92c197f3cee52912b2c03">gid</a></td></tr>
<tr class="separator:a9c9d22437de92c197f3cee52912b2c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac105b4180008cb3e672d57beead8382e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ac105b4180008cb3e672d57beead8382e">uid</a></td></tr>
<tr class="separator:ac105b4180008cb3e672d57beead8382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3b17a25e1fbc772f21eb4959a82724"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a9d3b17a25e1fbc772f21eb4959a82724">options</a></td></tr>
<tr class="separator:a9d3b17a25e1fbc772f21eb4959a82724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9d94cdfb893d777b4a4db81e7b5ac0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a0e9d94cdfb893d777b4a4db81e7b5ac0">user</a></td></tr>
<tr class="separator:a0e9d94cdfb893d777b4a4db81e7b5ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac583ce92b8e1c949cb6fef6bfe713d56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ac583ce92b8e1c949cb6fef6bfe713d56">ka_time</a></td></tr>
<tr class="separator:ac583ce92b8e1c949cb6fef6bfe713d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baab4285c679fbe027c2504621d7410"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a3baab4285c679fbe027c2504621d7410">ka_probes</a></td></tr>
<tr class="separator:a3baab4285c679fbe027c2504621d7410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381342a398883d6204955ff3c1849ddd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a381342a398883d6204955ff3c1849ddd">ka_interval</a></td></tr>
<tr class="separator:a381342a398883d6204955ff3c1849ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1654d41bea6fb2f619b57e6a264b26a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlws__polarssl__context.html">SSL_CTX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a1654d41bea6fb2f619b57e6a264b26a4">provided_client_ssl_ctx</a></td></tr>
<tr class="separator:a1654d41bea6fb2f619b57e6a264b26a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e790dda6202604f73a03b6149bc12bb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a0e790dda6202604f73a03b6149bc12bb">provided_client_ssl_ctx</a></td></tr>
<tr class="separator:a0e790dda6202604f73a03b6149bc12bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdfd3c484689ba6f0f2cc91b38ce948"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a0cdfd3c484689ba6f0f2cc91b38ce948">max_http_header_data</a></td></tr>
<tr class="separator:a0cdfd3c484689ba6f0f2cc91b38ce948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b154e79abc1167ba4ac3539f4af6720"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a0b154e79abc1167ba4ac3539f4af6720">max_http_header_pool</a></td></tr>
<tr class="separator:a0b154e79abc1167ba4ac3539f4af6720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52f3237e144e9ddcab5e2cf91d1e419"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ae52f3237e144e9ddcab5e2cf91d1e419">count_threads</a></td></tr>
<tr class="separator:ae52f3237e144e9ddcab5e2cf91d1e419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e63e24c88289e0c8352377ef4d3646"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a45e63e24c88289e0c8352377ef4d3646">fd_limit_per_thread</a></td></tr>
<tr class="separator:a45e63e24c88289e0c8352377ef4d3646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfa3d51df2def3349a5cbf0d712822d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a6cfa3d51df2def3349a5cbf0d712822d">timeout_secs</a></td></tr>
<tr class="separator:a6cfa3d51df2def3349a5cbf0d712822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5d4e7d9f86b58a1c6fac14f0a5f5f9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#afa5d4e7d9f86b58a1c6fac14f0a5f5f9">ecdh_curve</a></td></tr>
<tr class="separator:afa5d4e7d9f86b58a1c6fac14f0a5f5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50db098a208f045f7811207d2bee4b9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ad50db098a208f045f7811207d2bee4b9">vhost_name</a></td></tr>
<tr class="separator:ad50db098a208f045f7811207d2bee4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8122cfc0810bafe51edb3ba6bf9a1251"><td class="memItemLeft" align="right" valign="top">const char *const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a8122cfc0810bafe51edb3ba6bf9a1251">plugin_dirs</a></td></tr>
<tr class="separator:a8122cfc0810bafe51edb3ba6bf9a1251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999866fcd15dbd621773436f97190458"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a999866fcd15dbd621773436f97190458">pvo</a></td></tr>
<tr class="separator:a999866fcd15dbd621773436f97190458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81697c6b763b5ef3ee52862bc70b07d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a81697c6b763b5ef3ee52862bc70b07d6">keepalive_timeout</a></td></tr>
<tr class="separator:a81697c6b763b5ef3ee52862bc70b07d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e95ba721f7bd2b676719f8093c23a2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ad0e95ba721f7bd2b676719f8093c23a2">log_filepath</a></td></tr>
<tr class="separator:ad0e95ba721f7bd2b676719f8093c23a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ffbb0d010309669611f8c4eda7d7f8"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__http__mount.html">lws_http_mount</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a13ffbb0d010309669611f8c4eda7d7f8">mounts</a></td></tr>
<tr class="separator:a13ffbb0d010309669611f8c4eda7d7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137a9b9de4f6a7993fed8746d551e616"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a137a9b9de4f6a7993fed8746d551e616">server_string</a></td></tr>
<tr class="separator:a137a9b9de4f6a7993fed8746d551e616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f88c0745adbd1d6b9b619b8de30209"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a57f88c0745adbd1d6b9b619b8de30209">pt_serv_buf_size</a></td></tr>
<tr class="separator:a57f88c0745adbd1d6b9b619b8de30209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d9e85e137f35fb006f2e4a53f0887a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#aa8d9e85e137f35fb006f2e4a53f0887a">max_http_header_data2</a></td></tr>
<tr class="separator:aa8d9e85e137f35fb006f2e4a53f0887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704940261951ced6b5d8191bd8b9bb2d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a704940261951ced6b5d8191bd8b9bb2d">ssl_options_set</a></td></tr>
<tr class="separator:a704940261951ced6b5d8191bd8b9bb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0bc0b28cd7d90ab306723d8ffa96fa"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#adb0bc0b28cd7d90ab306723d8ffa96fa">ssl_options_clear</a></td></tr>
<tr class="separator:adb0bc0b28cd7d90ab306723d8ffa96fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a1a25a7df3793f59047e20dd580078"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a33a1a25a7df3793f59047e20dd580078">ws_ping_pong_interval</a></td></tr>
<tr class="separator:a33a1a25a7df3793f59047e20dd580078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca0ec6b8675c13849bbdcdc0d50c9a3"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a8ca0ec6b8675c13849bbdcdc0d50c9a3">headers</a></td></tr>
<tr class="separator:a8ca0ec6b8675c13849bbdcdc0d50c9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b059b7ee248cba72a3a4fd6141b0b34"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a6b059b7ee248cba72a3a4fd6141b0b34">reject_service_keywords</a></td></tr>
<tr class="separator:a6b059b7ee248cba72a3a4fd6141b0b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbc1b141d16c1084ec4c543e7768a72"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#aadbc1b141d16c1084ec4c543e7768a72">external_baggage_free_on_destroy</a></td></tr>
<tr class="separator:aadbc1b141d16c1084ec4c543e7768a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce3b59950eca3203faa07381bbed5d7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#afce3b59950eca3203faa07381bbed5d7">_unused</a> [8]</td></tr>
<tr class="separator:afce3b59950eca3203faa07381bbed5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>struct <a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a> - parameters to create context and /or vhost with</p>
<p>This is also used to create vhosts.... if LWS_SERVER_OPTION_EXPLICIT_VHOSTS is not given, then for backwards compatibility one vhost is created at context-creation time using the info from this struct.</p>
<p>If LWS_SERVER_OPTION_EXPLICIT_VHOSTS is given, then no vhosts are created at the same time as the context, they are expected to be created afterwards. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="afce3b59950eca3203faa07381bbed5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce3b59950eca3203faa07381bbed5d7">&sect;&nbsp;</a></span>_unused</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lws_context_creation_info::_unused[8]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dummy </p>

</div>
</div>
<a id="ae52f3237e144e9ddcab5e2cf91d1e419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52f3237e144e9ddcab5e2cf91d1e419">&sect;&nbsp;</a></span>count_threads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::count_threads</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: how many contexts to create in an array, 0 = 1 </p>

</div>
</div>
<a id="afa5d4e7d9f86b58a1c6fac14f0a5f5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5d4e7d9f86b58a1c6fac14f0a5f5f9">&sect;&nbsp;</a></span>ecdh_curve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ecdh_curve</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: if NULL, defaults to initializing server with "prime256v1" </p>

</div>
</div>
<a id="a4a3d1155fc52f5048b481884f6fb947c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3d1155fc52f5048b481884f6fb947c">&sect;&nbsp;</a></span>extensions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__extension.html">lws_extension</a>* lws_context_creation_info::extensions</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: NULL or array of <a class="el" href="structlws__extension.html">lws_extension</a> structs listing the extensions this context supports. </p>

</div>
</div>
<a id="aadbc1b141d16c1084ec4c543e7768a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbc1b141d16c1084ec4c543e7768a72">&sect;&nbsp;</a></span>external_baggage_free_on_destroy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lws_context_creation_info::external_baggage_free_on_destroy</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: NULL, or pointer to something externally malloc'd, that should be freed when the context is destroyed. This allows you to automatically sync the freeing action to the context destruction action, so there is no need for an external free() if the context succeeded to create. </p>

</div>
</div>
<a id="a45e63e24c88289e0c8352377ef4d3646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e63e24c88289e0c8352377ef4d3646">&sect;&nbsp;</a></span>fd_limit_per_thread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::fd_limit_per_thread</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: nonzero means restrict each service thread to this many fds, 0 means the default which is divide the process fd limit by the number of threads. </p>

</div>
</div>
<a id="a9c9d22437de92c197f3cee52912b2c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9d22437de92c197f3cee52912b2c03">&sect;&nbsp;</a></span>gid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::gid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: group id to change to after setting listen socket, or -1. </p>

</div>
</div>
<a id="a8ca0ec6b8675c13849bbdcdc0d50c9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca0ec6b8675c13849bbdcdc0d50c9a3">&sect;&nbsp;</a></span>headers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a>* lws_context_creation_info::headers</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: pointer to optional linked list of per-vhost canned headers that are added to server responses </p>

</div>
</div>
<a id="aef917c0b23976a264d2474901b4f5aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef917c0b23976a264d2474901b4f5aa3">&sect;&nbsp;</a></span>http_proxy_address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::http_proxy_address</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: If non-NULL, attempts to proxy via the given address. If proxy auth is required, use format "username:password\@server:port" </p>

</div>
</div>
<a id="a7b59f2bdc869871e7bde232db94f5ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b59f2bdc869871e7bde232db94f5ca6">&sect;&nbsp;</a></span>http_proxy_port</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::http_proxy_port</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: If http_proxy_address was non-NULL, uses this port </p>

</div>
</div>
<a id="a75434932bb5df54665ea678eb8ac104a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75434932bb5df54665ea678eb8ac104a">&sect;&nbsp;</a></span>iface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::iface</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: NULL to bind the listen socket to all interfaces, or the interface name, eg, "eth2" If options specifies LWS_SERVER_OPTION_UNIX_SOCK, this member is the pathname of a UNIX domain socket. you can use the UNIX domain sockets in abstract namespace, by prepending an at symbol to the socket name. </p>

</div>
</div>
<a id="a381342a398883d6204955ff3c1849ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381342a398883d6204955ff3c1849ddd">&sect;&nbsp;</a></span>ka_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::ka_interval</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: if ka_time was nonzero, how long to wait before each ka_probes attempt </p>

</div>
</div>
<a id="a3baab4285c679fbe027c2504621d7410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3baab4285c679fbe027c2504621d7410">&sect;&nbsp;</a></span>ka_probes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::ka_probes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: if ka_time was nonzero, after the timeout expires how many times to try to get a response from the peer before giving up and killing the connection </p>

</div>
</div>
<a id="ac583ce92b8e1c949cb6fef6bfe713d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac583ce92b8e1c949cb6fef6bfe713d56">&sect;&nbsp;</a></span>ka_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::ka_time</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: 0 for no TCP keepalive, otherwise apply this keepalive timeout to all libwebsocket sockets, client or server </p>

</div>
</div>
<a id="a81697c6b763b5ef3ee52862bc70b07d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81697c6b763b5ef3ee52862bc70b07d6">&sect;&nbsp;</a></span>keepalive_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::keepalive_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: (default = 0 = 60s) seconds to allow remote client to hold on to an idle HTTP/1.1 connection </p>

</div>
</div>
<a id="ad0e95ba721f7bd2b676719f8093c23a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e95ba721f7bd2b676719f8093c23a2">&sect;&nbsp;</a></span>log_filepath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::log_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: filepath to append logs to... this is opened before any dropping of initial privileges </p>

</div>
</div>
<a id="a0cdfd3c484689ba6f0f2cc91b38ce948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdfd3c484689ba6f0f2cc91b38ce948">&sect;&nbsp;</a></span>max_http_header_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short lws_context_creation_info::max_http_header_data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: The max amount of header payload that can be handled in an http request (unrecognized header payload is dropped) </p>

</div>
</div>
<a id="aa8d9e85e137f35fb006f2e4a53f0887a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d9e85e137f35fb006f2e4a53f0887a">&sect;&nbsp;</a></span>max_http_header_data2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::max_http_header_data2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: if max_http_header_data is 0 and this is nonzero, this will be used in place of the default. It's like this for compatibility with the original short version, this is unsigned int length. </p>

</div>
</div>
<a id="a0b154e79abc1167ba4ac3539f4af6720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b154e79abc1167ba4ac3539f4af6720">&sect;&nbsp;</a></span>max_http_header_pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short lws_context_creation_info::max_http_header_pool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: The max number of connections with http headers that can be processed simultaneously (the corresponding memory is allocated for the lifetime of the context). If the pool is busy new incoming connections must wait for accept until one becomes free. </p>

</div>
</div>
<a id="a13ffbb0d010309669611f8c4eda7d7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ffbb0d010309669611f8c4eda7d7f8">&sect;&nbsp;</a></span>mounts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__http__mount.html">lws_http_mount</a>* lws_context_creation_info::mounts</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: optional linked list of mounts for this vhost </p>

</div>
</div>
<a id="a9d3b17a25e1fbc772f21eb4959a82724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3b17a25e1fbc772f21eb4959a82724">&sect;&nbsp;</a></span>options</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::options</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST + CONTEXT: 0, or LWS_SERVER_OPTION_... bitfields </p>

</div>
</div>
<a id="a8122cfc0810bafe51edb3ba6bf9a1251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8122cfc0810bafe51edb3ba6bf9a1251">&sect;&nbsp;</a></span>plugin_dirs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const* lws_context_creation_info::plugin_dirs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: NULL, or NULL-terminated array of directories to scan for lws protocol plugins at context creation time </p>

</div>
</div>
<a id="a424a5ce268d6903e42243be94487ab85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424a5ce268d6903e42243be94487ab85">&sect;&nbsp;</a></span>port</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::port</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Port to listen on... you can use CONTEXT_PORT_NO_LISTEN to suppress listening on any port, that's what you want if you are not running a websocket server at all but just using it as a client </p>

</div>
</div>
<a id="abb90ffb3e6d6db2db20f529d61bd9122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb90ffb3e6d6db2db20f529d61bd9122">&sect;&nbsp;</a></span>protocols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a>* lws_context_creation_info::protocols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Array of structures listing supported protocols and a protocol- specific callback for each one. The list is ended with an entry that has a NULL callback pointer. </p>

</div>
</div>
<a id="a1654d41bea6fb2f619b57e6a264b26a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1654d41bea6fb2f619b57e6a264b26a4">&sect;&nbsp;</a></span>provided_client_ssl_ctx <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlws__polarssl__context.html">SSL_CTX</a>* lws_context_creation_info::provided_client_ssl_ctx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: If non-null, swap out libwebsockets ssl implementation for the one provided by provided_ssl_ctx. Libwebsockets no longer is responsible for freeing the context if this option is selected. </p>

</div>
</div>
<a id="a0e790dda6202604f73a03b6149bc12bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e790dda6202604f73a03b6149bc12bb">&sect;&nbsp;</a></span>provided_client_ssl_ctx <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lws_context_creation_info::provided_client_ssl_ctx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dummy if ssl disabled </p>

</div>
</div>
<a id="a57f88c0745adbd1d6b9b619b8de30209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f88c0745adbd1d6b9b619b8de30209">&sect;&nbsp;</a></span>pt_serv_buf_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::pt_serv_buf_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: 0 = default of 4096. This buffer is used by various service related features including file serving, it defines the max chunk of file that can be sent at once. At the risk of lws having to buffer failed large sends, it can be increased to, eg, 128KiB to improve throughput. </p>

</div>
</div>
<a id="a999866fcd15dbd621773436f97190458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999866fcd15dbd621773436f97190458">&sect;&nbsp;</a></span>pvo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a>* lws_context_creation_info::pvo</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: pointer to optional linked list of per-vhost options made accessible to protocols </p>

</div>
</div>
<a id="a6b059b7ee248cba72a3a4fd6141b0b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b059b7ee248cba72a3a4fd6141b0b34">&sect;&nbsp;</a></span>reject_service_keywords</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a>* lws_context_creation_info::reject_service_keywords</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: Optional list of keywords and rejection codes + text.</p>
<p>The keywords are checked for existing in the user agent string.</p>
<p>Eg, "badrobot" "404 Not Found" </p>

</div>
</div>
<a id="a137a9b9de4f6a7993fed8746d551e616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137a9b9de4f6a7993fed8746d551e616">&sect;&nbsp;</a></span>server_string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::server_string</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: string used in HTTP headers to identify server software, if NULL, "libwebsockets". </p>

</div>
</div>
<a id="a4f8e65c3a059d3b586fafa9ef3282c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8e65c3a059d3b586fafa9ef3282c29">&sect;&nbsp;</a></span>ssl_ca_filepath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ssl_ca_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: CA certificate filepath or NULL </p>

</div>
</div>
<a id="ac62b0f0e8e402412ba5011d15c244103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62b0f0e8e402412ba5011d15c244103">&sect;&nbsp;</a></span>ssl_cert_filepath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ssl_cert_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: If libwebsockets was compiled to use ssl, and you want to listen using SSL, set to the filepath to fetch the server cert from, otherwise NULL for unencrypted </p>

</div>
</div>
<a id="a3e1516fd7fed26bfa77c0246ed26c2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1516fd7fed26bfa77c0246ed26c2eb">&sect;&nbsp;</a></span>ssl_cipher_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ssl_cipher_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: List of valid ciphers to use (eg, "RC4-MD5:RC4-SHA:AES128-SHA:AES256-SHA:HIGH:!DSS:!aNULL" or you can leave it as NULL to get "DEFAULT" </p>

</div>
</div>
<a id="adb0bc0b28cd7d90ab306723d8ffa96fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0bc0b28cd7d90ab306723d8ffa96fa">&sect;&nbsp;</a></span>ssl_options_clear</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long lws_context_creation_info::ssl_options_clear</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Any bits set here will be cleared as SSL options </p>

</div>
</div>
<a id="a704940261951ced6b5d8191bd8b9bb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704940261951ced6b5d8191bd8b9bb2d">&sect;&nbsp;</a></span>ssl_options_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long lws_context_creation_info::ssl_options_set</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Any bits set here will be set as SSL options </p>

</div>
</div>
<a id="ab9ec8893e0f7843cf5d783d2f350ef14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ec8893e0f7843cf5d783d2f350ef14">&sect;&nbsp;</a></span>ssl_private_key_filepath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ssl_private_key_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: filepath to private key if wanting SSL mode; if this is set to NULL but sll_cert_filepath is set, the OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY callback is called to allow setting of the private key directly via openSSL library calls </p>

</div>
</div>
<a id="af3fb447be15c4fcb01d3285a6678ab54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fb447be15c4fcb01d3285a6678ab54">&sect;&nbsp;</a></span>ssl_private_key_password</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ssl_private_key_password</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: NULL or the passphrase needed for the private key </p>

</div>
</div>
<a id="a6cfa3d51df2def3349a5cbf0d712822d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfa3d51df2def3349a5cbf0d712822d">&sect;&nbsp;</a></span>timeout_secs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::timeout_secs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: various processes involving network roundtrips in the library are protected from hanging forever by timeouts. If nonzero, this member lets you set the timeout used in seconds. Otherwise a default timeout is used. </p>

</div>
</div>
<a id="ac8a75b7b259a3c3a5fbb4219a3f06c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a75b7b259a3c3a5fbb4219a3f06c29">&sect;&nbsp;</a></span>token_limits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__token__limits.html">lws_token_limits</a>* lws_context_creation_info::token_limits</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: NULL or struct <a class="el" href="structlws__token__limits.html">lws_token_limits</a> pointer which is initialized with a token length limit for each possible WSI_TOKEN_ </p>

</div>
</div>
<a id="ac105b4180008cb3e672d57beead8382e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac105b4180008cb3e672d57beead8382e">&sect;&nbsp;</a></span>uid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::uid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: user id to change to after setting listen socket, or -1. </p>

</div>
</div>
<a id="a0e9d94cdfb893d777b4a4db81e7b5ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9d94cdfb893d777b4a4db81e7b5ac0">&sect;&nbsp;</a></span>user</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lws_context_creation_info::user</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: optional user pointer that can be recovered via the context pointer using lws_context_user </p>

</div>
</div>
<a id="ad50db098a208f045f7811207d2bee4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50db098a208f045f7811207d2bee4b9">&sect;&nbsp;</a></span>vhost_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::vhost_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: name of vhost, must match external DNS name used to access the site, like "warmcat.com" as it's used to match Host: header and / or SNI name for SSL. </p>

</div>
</div>
<a id="a33a1a25a7df3793f59047e20dd580078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a1a25a7df3793f59047e20dd580078">&sect;&nbsp;</a></span>ws_ping_pong_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short lws_context_creation_info::ws_ping_pong_interval</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: 0 for none, else interval in seconds between sending PINGs on idle websocket connections. When the PING is sent, the PONG must come within the normal timeout_secs timeout period or the connection will be dropped. Any RX or TX traffic on the connection restarts the interval timer, so a connection which always sends or receives something at intervals less than the interval given here will never send PINGs / expect PONGs. Conversely as soon as the ws connection is established, an idle connection will do the PING / PONG roundtrip as soon as ws_ping_pong_interval seconds has passed without traffic </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lib/<a class="el" href="libwebsockets_8h_source.html">libwebsockets.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
